### インデックスとは

- テーブルの特定の列に対して作成されるデータ構造
- データの検索や並び替えを高速化する仕組み

#### もしインデックスがなかったら

- DBMSはテーブルの全ての行を上から順番に読み込んでいく

*主キーは何もしなくても自動でインデックスが張られる

---

### インデックスの使い方(MySQL)

- インデックスを張る
```sql
-- CREATE INDEXを使う場合
CREATE INDEX
    <index_name>
ON <table_name> (<col_name>, ..., <col_name>);

-- ALTER TABLEを使う場合
ALTER TABLE <table_name>
ADD INDEX <index_name> (<col_name>, ..., <col_name>)
```

<br>

- インデックスを削除する
```sql
DROP INDEX <index_name> ON <table_name>;
```

<br>

- インデックスの一覧を表示する  
    - INFORMATION_SCHEMA データベースの中の STATISTICS テーブルに情報が格納されている
    - もしくは SHOW INDEX を使う
```sql
-- 方法1
SELECT 
    *
FROM INFORMATION_SCHEMA.STATISTICS
WHERE table_schema = <db_name>
      AND
      table_name = <table_name>;


-- 方法2
-- FROM <table> FROM <schema>の代わりにFROM <schema>.<table>でも可
SHOW INDEX FROM <table> (FROM <schema>)
```

---

### インデックスを利用して処理が高速になる例

- WHERE句の絞り込み条件にインデックスを張ったカラムを利用する  
*LIKEで検索をする場合
```sql
-- nameにindexを貼っているとする

-- 下記のsqlはAuまではインデックスが効く
SELECT ~ WHERE name LIKE 'Au%'

-- 下記はインデックスが効かない=全件走査される
SELECT ~ WHERE name LIKE '%lia'
```

<br>

- ORDER BY の並び替えの基準にインデックスを張ったカラムを利用する

<br>

- JOIN の ON の結合条件にインデックスを張ったカラムを利用する


--- 

### インデックスを使うことによる問題

- ストレージの容量を使うので、インデックスの多用に注意

- テーブル中のインデックスを張ったカラムのデータが変更されると、インデックスも書き換える必要があるため、INSERT/UPDATE/DELETEの処理の時間が増える  

---

### インデックスの仕組み

代表的なものとしてはB木やB+木がある

---

### 複合インデックス

- あるテーブルにおいて複数のカラムを合わせたインデックス

- インデックス作成時の<font color="red">カラムの順番は重要</font>


```sql
-- 以下のようにインデックスを張ったとする
CREATE INDEX
    index_students
ON students (name, age);
```
- 複合インデックスが使える例
    1. 複合インデックスが張られたカラム全てで検索する
    2. 複合インデックスの1番目に指定したカラムで検索する

- 逆に複合インデックスが使えない例
    1. インデックスの張られていないカラムで検索
    2. 複合インデックスの2番目以降に指定したカラムで検索する

---

### インデックスのメンテナンス

- なぜメンテナンスが必要なのか: インデックスが張られたテーブルに対してデータの追加/削除/変更によってインデックス内部のデータ木構造も変化し、最適な構造でなくなる場合があるから。

- InnoDB(MySQLのストレージエンジン)は特定の条件下でANALYZE TABLEを自動で実行し、統計情報を更新する。  
*ストレージエンジン: データベースエンジンとも呼ばれ、DBへデータの読み込み/更新/追加/削除を行うプログラム。DBMSのUIを使わなくても、DBエンジンのAPIを利用すれば、それ経由でDBの操作ができる。  

#### メンテナンス方法

- OPTIMIZE TABLE を使う  
    - ディスクに格納されているテーブルデータの再編成を行う。(削除/追加を繰り返すことで、テーブルデータはとびとびにディスクに格納されることになるから)

    - また、同様にインデックデータの物理記憶領域も再編成される

    - この処理の間テーブルは排他ロックされるので注意
```sql
OPTIMIZE TABLE <table_name>;
```

---

### いいインデックスの貼り方

- データの分布が多いカラムにインデックスを張るといい  
    例:ユニークID、生年月日、更新日時

- データの分布が狭いカラムにインデックスを張っても、インデックスの効果が薄いことが多い
    例: 性別、フラグ、カテゴリ系